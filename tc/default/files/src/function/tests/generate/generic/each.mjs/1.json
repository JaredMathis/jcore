{
 "file_path": "src\\function\\tests\\generate\\generic\\each.mjs",
 "part_id": "4a634f4d-e051-4a33-a913-efc021b64ec2",
 "hunks": [
  "0+import { function_auto_after } from '../../../auto/after.mjs';\nimport { function_map_multiple } from '../../../map/multiple.mjs';\nimport { refactor_metadata_generated_add_function } from '../../../../refactor/metadata/generated/add/function.mjs';\nimport { function_add_with_statements_synchronized } from '../../../add/with/statements/synchronized.mjs';\nimport { js_parse_statement } from '../../../../js/parse/statement.mjs';\nimport { json_equal } from '../../../../json/equal.mjs';\nimport { js_statement_assignment } from '../../../../js/statement/assignment.mjs';\nimport { error } from '../../../../error.mjs';\nimport { log } from '../../../../log.mjs';\nimport { assert } from '../../../../assert.mjs';\nimport { js_code_call_expression_statement_with_args_code } from '../../../../js/code/call/expression/statement/with/args/code.mjs';\nimport { throws } from '../../../../throws.mjs';\nimport { function_name_get } from '../../../name/get.mjs';\nimport { js_code_call_expression_with_args_code } from '../../../../js/code/call/expression/with/args/code.mjs';\nimport { js_code_call_expression_with_args } from '../../../../js/code/call/expression/with/args.mjs';\nimport { json_to } from '../../../../json/to.mjs';\nimport { list_map } from '../../../../list/map.mjs';\nimport { function_run } from '../../../run.mjs';\nexport async function function_tests_generate_generic_each(function_name, test_name, args, on_has_error) {\n    let expected;\n    let has_error = false;\n    try {\n        expected = await function_run(function_name, args);\n    } catch (e) {\n        has_error = true;\n    }\n    if (has_error) {\n        if (on_has_error()) {\n            return;\n        }\n    }\n    let args_code = list_map(args, json_to);\n    let ce_function = js_code_call_expression_with_args(function_name, args_code);\n    let statements_code;\n    let statement_assert;\n    if (has_error) {\n        let ce_throws = js_code_call_expression_with_args_code(function_name_get(throws), `() => ${ ce_function }`);\n        statement_assert = js_code_call_expression_statement_with_args_code(function_name_get(assert), ce_throws);\n        statements_code = [statement_assert];\n        log({\n            args,\n            error: true\n        });\n    } else {\n        let identifier_expected = 'expected';\n        let statement_expected = js_statement_assignment(identifier_expected, json_to(expected));\n        let identifier_actual = 'actual';\n        let statement_function = js_statement_assignment(identifier_actual, ce_function);\n        let ce_equal = js_code_call_expression_with_args(function_name_get(json_equal), [\n            identifier_actual,\n            identifier_expected\n        ]);\n        statement_assert = js_code_call_expression_statement_with_args_code(function_name_get(assert), ce_equal);\n        statements_code = [\n            statement_expected,\n            statement_function,\n            statement_assert\n        ];\n        log({\n            args,\n            expected\n        });\n    }\n    let statements = list_map(statements_code, js_parse_statement);\n    await function_add_with_statements_synchronized(test_name, statements, false);\n    let refactors = [refactor_metadata_generated_add_function];\n    let names = list_map(refactors, function_name_get);\n    await function_map_multiple(names, test_name);\n    await function_auto_after(test_name);\n}"
 ]
}