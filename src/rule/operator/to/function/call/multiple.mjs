import { metadata } from '../../../../../metadata.mjs';
import { multiply } from '../../../../../multiply.mjs';
import { subtract } from '../../../../../subtract.mjs';
import { or } from '../../../../../or.mjs';
import { js_node_is_logical_expression } from '../../../../../js/node/is/logical/expression.mjs';
import { js_node_is_binary_expression } from '../../../../../js/node/is/binary/expression.mjs';
import { and } from '../../../../../and.mjs';
import { rule_operator_to_function_call_generic } from './generic.mjs';
import { equal } from '../../../../../equal.mjs';
import { arguments_assert } from '../../../../../arguments/assert.mjs';
import { equal_not } from '../../../../../equal/not.mjs';
import { less_than } from '../../../../../less/than.mjs';
import { add } from '../../../../../add.mjs';
export async function rule_operator_to_function_call_multiple() {
    arguments_assert(arguments, []);
    let v = '===';
    await rule_operator_to_function_call_generic(equal, v, js_node_is_binary_expression);
    let v_2 = '!==';
    await rule_operator_to_function_call_generic(equal_not, v_2, js_node_is_binary_expression);
    let v_3 = '&&';
    await rule_operator_to_function_call_generic(and, v_3, js_node_is_logical_expression);
    let v_4 = '||';
    await rule_operator_to_function_call_generic(or, v_4, js_node_is_logical_expression);
    let v_5 = '<';
    await rule_operator_to_function_call_generic(less_than, v_5, js_node_is_binary_expression);
    let v_6 = '-';
    await rule_operator_to_function_call_generic(subtract, v_6, js_node_is_binary_expression);
    let v_7 = '*';
    await rule_operator_to_function_call_generic(multiply, v_7, js_node_is_binary_expression);
    let v_8 = '+';
    await rule_operator_to_function_call_generic(add, v_8, js_node_is_binary_expression);
    metadata([]);
}